% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/operator-jump.R
\name{jump_correct}
\alias{jump_correct}
\title{Jump Correction for Spectral Data}
\usage{
jump_correct(
  data,
  splices,
  reference = 2,
  method = "additive",
  measurement_cols = NULL
)
}
\arguments{
\item{data}{A data frame containing spectral data with a 'wavelength' column
and one or more measurement columns, or a ruffs_spectra object.}

\item{splices}{Numeric vector of wavelength values indicating detector
boundaries where jumps may occur. For ASD instruments, typically
c(1000, 1800). For SVC instruments, c(990, 1850).}

\item{reference}{Integer indicating which detector segment to use as the
reference (1-based indexing). This segment remains unchanged while others
are adjusted to match it. Default is 2 (middle detector for 3-detector systems).}

\item{method}{Character string specifying the correction method. Currently
only "additive" is supported.}

\item{measurement_cols}{Character vector of column names to apply correction to.
If NULL (default), applies to all numeric columns except 'wavelength'.}
}
\value{
A data frame or ruffs_spectra object with jump-corrected measurements.
The structure and class of the input are preserved.
}
\description{
Corrects for discontinuities (jumps) at detector boundaries after overlap
stitching. After overlapping wavelength regions are removed by
\code{overlap_stitching()}, small step artifacts can remain at the detector
junctions. This function applies additive corrections to create smooth
transitions between detector regions.
}
\details{
The additive correction method works by:
\enumerate{
\item Dividing the spectrum into segments based on splice points
\item Keeping the reference segment unchanged
\item For segments to the right: shifting each so its first value matches
the last value of the previous segment
\item For segments to the left: shifting each so its last value matches
the first value of the next segment
}

This creates a continuous spectrum by removing step discontinuities while
preserving the relative spectral shape within each detector region.

\strong{Important:} This function should be applied AFTER \code{overlap_stitching()}
has removed overlapping wavelength regions. If overlaps still exist, the
correction may not work as intended.
}
\section{Choosing Splice Points}{

Splice points should match the detector boundaries of your instrument:
\itemize{
\item ASD instruments: typically 1000 nm (VNIR/SWIR1) and 1800 nm (SWIR1/SWIR2)
\item SVC instruments: typically 990 nm and 1800 nm
\item PSR instruments: typically 1000 nm and 1800 nm
}
}

\section{Choosing Reference Segment}{

The reference segment is the detector region that remains unchanged:
\itemize{
\item For 3-detector systems: reference = 2 (middle detector, usually SWIR1)
\item For 2-detector systems: reference = 1 or 2 depending on which is more reliable
}
}

\examples{
\dontrun{
# Single spectrum processing
data <- svcreader("field_data.sig", data_type = "reflectance")
data_interp <- interpolation(data, seq(350, 2500, 1))
data_stitched <- overlap_stitching(data_interp, method = "average")
data_corrected <- jump_correct(data_stitched, splices = c(990, 1850), reference = 2)

# Collection processing (RUFFS pattern)
svcdata <- svcreader(directory = "data/", data_type = "reflectance", recursive = TRUE)
specs_interpolation <- apply_to_collection(svcdata, interpolation, seq(350, 2500, 1))
specs_stitched <- apply_to_collection(specs_interpolation, overlap_stitching, method = "average")
specs_corrected <- apply_to_collection(specs_stitched, jump_correct, 
                                       splices = c(990, 1850), reference = 2)

# For ASD data
asd_data <- asdreader("spectrum.asd", data_type = "reflectance")
asd_corrected <- asd_data \%>\%
  interpolation(seq(350, 2500, 1)) \%>\%
  overlap_stitching(method = "average") \%>\%
  jump_correct(splices = c(1000, 1800), reference = 2)

# Apply to specific columns only
data_corrected <- jump_correct(data_stitched, 
                                splices = c(990, 1850),
                                reference = 2,
                                measurement_cols = c("reflectance", "radiance"))
}

}
